## 表达式的学习

### 表达式基础

- 表达式： `x = 3` //两个操作数  （可以求值并返回计算结果）

- 最基本的表达式：变量+字面值；通常来说，表达式包括操作符（小的表达式会组成大的表达式）

- 操作符的特性：

  - 接受几个操作数：一元、二元（+）、三元

  - 操作数的类型————类型转换（3 + 3.2）

  - 操作数是左值还是右值（=左面一定是左值）

  - 结果的类型

  - 结果是左值还是右值

  - 操作符的优先级（* > +）与结合性，通过小括号改变运算顺序

    C++ operator precedence（associativity）

  - 结合性：左结合，右结合

  - 操作符的重载：不改变操作数的个数，优先级与结合性（类）

- 操作数求值顺序的不确定性

  fun(x = x+1, x = x+1); //此时两个x+1哪个先执行是不确定的，取决于不同的编译器clang g++

### 左值与右值

- 不能写 3 = x
- C ++左值不一定能放在等号左边（`const int`），右值也可以放在等号左边（ `struct Str{};` `Str() = Str()` ）
- 划分是针对表达式的，而非对象
  - expression：glvalue（泛左值） rvalue （右值）
  - glvalue: lvalue（左值）, xvalue（亡值）
  - rvalue: xvalue（亡值）， prvalue（纯右值）
- 泛左值：是个表达式，其求值结果可以确定一个对象，位域或函数（可以获取到关联到的内存）
- 纯右值：某个运算符的操作数（*数字3*）或void表达式；初始化某个对象或位域（`int x = 3`）
- 亡值：代表资源可以重新被使用的泛左值
- 左值可以转化为右值（`int y = x;x + y`;）
- 临时具体化：temporary materialization  prvalue---> xvalue
  - `struct Str{ int x; };` ` Str().x`   //加了.x，不再是纯右值，而是将亡值
  - void fun(const int& ptr) {};  {fun(3) ;} //3被转化为将亡值
- decltype:
  - prvalue--type; lvalue--type&; xvalue--type&&
  - prvalue:  `decltype(3) x     //等价于 int x`
  - lvalue:    `decltype((x)) y = x    //等价于 int &y = x`
  - xvalue: `decltype(std::move(x)) y = std::move(x)   //等价于 int &&y = std::move(x)`(<utility>)//右值引用，不能绑定左值

### 类型转换

- 一些操作符需要其操作数具有特定的类型（3 + 0.5）

- 隐式类型转换

  - 字符串不能转化为double
  - 引入一个有限长度的标准转换序列（implict_conversion）:整型提升，浮点提升；整形转换，浮点转换

- 显式类型转换

  - `static_cast<double>(3) + 0.5`

  - `static_cast<double>(x) + y`//隐式转换左值为右值，再显式转换

  - 编译期转换；运行期转换：`dynamic_cast`,安全性更好，性能变差

  - `const int* ptr; const_cast<int*>(ptr) ;` //去掉const

  - reinterpret_cast：指针相关的解码转换

    `int z = 7;`
    `int* ptr = &z;`
    `double* ptr2 = reinterpret_cast<double*>(ptr);  //此时ptr2内不再是7，且不固定`

    不固定的原因是int和double占用内存不一样，如果是float，都不占多余内存，每次都一样，但也都不是7

  - C类型转化   `int(x)`不建议使用

  - C++不建议使用显式类型转换


### 算术操作符

- 一元: + -    （+x）//正负号 优先级最高

- 二元：+ - （ / * %） //括号内优先级更高

- 均为左结合（优先级相同，从左到右算）

- 一般操作数均为算术类型的右值；但+-和正号+可以结合指针（ptr + 1）

  `int a[3] = {1, 2, 3};  const auto& x = +a //此时x是int* const &` 为了还要x是指针时

- +一元操作符会带来好处：整数提升

  `short x = 3; auto y = +x  //此时y类型为int`

- 整数相除，向0取整

- 求余只接受整数，符号与第一个操作数相同

  m / n * n + m%n == m

### 逻辑与关系操作符

- 第三优先级 14&&，15||

- 关系操作符接受算数或指针类型操作数，返回bool

- 操作数与返回值均为右值

- 除逻辑 非外，均为左结合

- 逻辑 与 优先级高于 逻辑 或

- 与 和 或 具有短路特性  // 有false值就不会对后面的表达式进行编译，只计算左边

  `int* ptr = nullptr; if(ptr && (*ptr == 3))`  // 不会进行ptr解码的危险操作

- 通常来说，不要将多个操作符串联

- 要 if（a） 而不要 if（a == true）// 后面会把ture变成1（优先bool转int）

- spaceship <=>: （C++2a）

  `if(a > b){}; else if(a<b){};else{}   //耗费资源`

  `auto res = (a<=>b)；`

  `if(res>0){}; else if(res<0){};else{res==0} // 一次判断`

  返回 weak_ordering(等价但不相等);   strong_ordering;   particial_ordering(NaN的比较时返回的值，浮点数的spaceship比较可能会返回这个类型);其中的一个类型

  `if(res== std::strong_ordering::greater)`

### 位操作符

- 接受右值，进行位运算，返回右值

- ~ 按位取反 11-13 & ^ |（与，异或，或），除取反外。都是左结合

  signed char x = 3;   ~x--> -4//   00000011  --> 11111100

  signed char y = 5；x&y--> 1// 00000011&00000101 --> 00000001

  signed char y = 5；x|y--> 7//  00000011|00000101 --> 00000111

  signed char y = 5；x^y--> 6//  00000011^00000101 --> 00000110

- 计算过程会包含整数提升 intergrate promotion  auto y = ~x  // y是 int

- 位操作没有短路逻辑

- 移位操作  <<  >>  补符号位(负数1正数0)

  signed char x = 3;   x << 1--> 6//   00000011  --> 00000110

  signed char x = 3;   x >> 1--> 1//   00000011  --> 00000001

  移位操作一定情况下等于乘（除）2的幂次，但速度更快；-4 << 2 -- > -16 左乘右除

- 整数的符号对位操作符的影响：

  - 0xff    11111111   255

  - unsigned char x = 0xff; // 11111111

    auto y = ~x  //000..0011111111  --> 111..1100000000   此时y = -255（提升为int位数变多）

  - signed char x = 0xff; // 11111111

    auto y = ~x  //111..1111111111  --> 000..0000000000   此时y = 0（提升为int位数变多，但第一位为符号位，都填了1） char类型，则行为不确定

  - 右移会保证符号，左移不能保证（可能会溢出）

### 赋值操作符

- 左操作数为可修改的左值（不能是`const int`），右操作数为可转换为左操作数的右值 16优先级

- 右结合  （x = y = 3）

- 其求值结果为左操作数 （y = 3的求值结果就是y）（（x = 5）=2 //合法）

- 引入大括号（初始化列表）防止收缩转换（narrowing conversion)

  short x；x = 0x8000003;  x --> 3  //收缩转换，输入位数溢出就只赋值后面的几位

  short x；x ={0x8000003} ;  x  -->  3  //收缩转换，编译会报错，warning变error

- 复合赋值  x = x+2   -->  x `+=` 2

- x ^=y^=x^=y   xy的值交换（节省内存）

### 自增与自减运算符

- ++x   -->   x += 1;   --x  --> x -= 1  (a++ 优先级为2，++a优先级为3)后缀优先级更高
- 后缀返回原始值，前缀返回变化后的值（前缀返回左值，后缀返回右值）
- 操作数为左值，建议前缀形式

### 其他操作符

- 成员访问操作符  .   ->   应用于结构体和类当中

  Struct Str{ int x; }  main{  Str a;  a.x;   Str* ptr = &a; (*ptr).x  //小括号不能省，.优先级高于 *}

  - -> 等价于  (*).        ( *ptr).x   // 等同于ptr->x;

  - .的左操作数为左值时返回左值（a.x返回左值），右值时返回xvalue

    decltype（a.x） y // int y  ；视为实体（一般左值会返回一个引用）

    decltype（（a.x）） y  // 报错，因为引用需要初始化

    decltype（（a.x）） y = a . x   //  int& y  = a.x

    decltype（（Str().x））y  = std::move(a.x) // int && y = std::move(a.x)  y的类型为右值引用（decltype右值时返回右值引用）

  -  ->的左操作数为指针返回左值

    decltype（（ptr->x）） y = a . x   //  int& y  = a.x  为int型的左值时返回int型的引用

- 条件操作符

  - 唯一三元操作符

    `ture ? 3: 5`    // 3

  - 第一个操作数接受可以转化为bool类型的表达式，并根据bool类型决定对第二或第三操作数进行求值，第二和第三操作数的类型必须相同（*保证返回类型相同*）

  - 如果表达式均为左值，返回左值，否则返回右值

  - 右结合性，可以嵌套

    int score = 100；

    (score > 0) ? 1 : (score == 0) ? 0 : -1  // 会先算score == 0    返回1

    ((score > 0) ? 1 : (score == 0) )? 0 : -1  //  返回0      1？0：-1

- 逗号操作符

  - 确保操作数从左到右求值  2, 3

  - 求值结果为右操作数   2, 3 // 3

  - 左结合性（2，3，4，5） // 5

    int x = 1; int y = 2; ++x, ++y;// 保证++x先算

- sizeof() 运算符

  - 产生类型***对象表示***时的字节数
  - 产生表达式***对象表示***时的字节数（求值时）
  - 不会实际求值，只会返回相应尺寸

- 其他

  -  :: 域解析
  - () 函数调用
  - [] 索引
  - throw 抛出异常操作符

- C++17会对表达式的求值顺序进行限定

