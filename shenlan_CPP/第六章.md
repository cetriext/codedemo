# 函数

## 函数基础

- 函数：封装了一段代码，可以在执行过程中被反复调用

  函数头：

  - 函数名称：标识符用于后续调用；不能包含特殊字符，不能包含C++本身的关键字（int等）

  - 形式参数：代表函数的输入参数
  - 返回类型：函数执行完成后所返回的结果类型

  函数体：

  可以先声明，后定义

- 函数的声明只包含函数头，加分号；

- 函数声明可以出现多次，但函数的定义只能出现一次（存在例外情况）

- 声明经常会放到头文件中，但是只有声明没有定义时：编译期不会出错，但链接时期会出错；

- 函数调用

  - 需要提供函数名和实际参数

  - 实际参数 拷贝初始化 形式参数

  - 返回值会拷贝给函数的调用值

  - 栈帧结构（stackframe）：函数存储在栈中，内存地址由高到低（最先进的内存地址最高）后进先出（调用时把函数帧落在main上，执行后出栈，）

    函数内部顺序：先分配实参地址，再分配返回值地址，再分配局部变量；内存地址由高到低

  - *拷贝过程的（强制）省略：返回值优化，C++ 17后*（后续讨论）

  - 外部链接（编译出的程序的外接接口，外部连接形式的函数由定义名称和形参类型共同唯一确定（是一个mangoling格式，由编译器决定，因此会出现一些问题），但C语言只能用名称唯一确定，不支持重载，接口就是函数名）

    可与在函数定义前加 ` extern “C” `强制C类型的函数，此时函数名可以重复，因为这两个函数其实是不一致的

## 函数详解——参数

- 函数可以在函数头的小括号中包含0到多个形参，不包含形参也可以在小括号中写void

- 对于非模板函数来说，每个形参都有确定类型，但形参可以没有名称

- 函数不能重复定义：名称相同且形参相同（形参的类型名称个数均一致）的函数算重复定义

- 调用过程：拷贝初始化形参，求职可能会不确定（之前的例子 fun（x++， x++）） C++会强制省略赋值临时对象（fun（1， int{}））这个类型不会被执行（如果这个结构体执行时会输出语句，那么这个语句不会输出，因为没有这个临时变量）

  **struct** Str{

    Str() = default;

    Str(**const** Str**&**) {

  ​    std:: cout << "Copy constructor is called . \n" ;

    }

  };

  **void** fun(Str par){

  }

  **int** main(){

    Str val;

    **int** x = 1;

    fun(val); *//会输出那句话*

    fun(Str{}); *//不会输出那句话*

    return 0;

  }

- 函数的传值，传址，传引用：

  传值：形参在函数体内的变化不会影响main中的实参；（原因是拷贝初始化）

  传址：传实参地址&arg，形参接受指针*par，这个时候函数内的变化会对arg进行演变（对指针的操作需要加星号，因为这个时候par是一个地址，星号为解引用操作）

  传引用：类似于正常传递，但会对原变量产生影响

  **void** fun(**int\*** par){

    ++*par;

  }

  **void** fun_(**int&** par){

    ++par;

  }

  **int** main(){

    **int** arg = 3;

    fun(&arg); 

    std::cout << arg <<'\n'; *//4*

    fun_(arg);

    std::cout << arg <<'\n'; *//5*

  }

- 函数传参中产生的类型退化：

  **int** a[3]; **auto** b = a; 拷贝初始化中出现的类型退化，此时b是指针

  （多维数组只有最高位会产生退化:  a[3] [4]  b-->(*int)[4]）

  阻止退化 auto& b = a;  此时形参(&par)[3]  (b类型 (&)int[3])

- 变长参数：可接受参数的个数可以发生改变

  - initializer_list  初始化列表（include这个）

    **void** fun5(std::initializer_list<**int**> par)       fun5({1,2,3,4,5}); //变长参数，但类型必须相同

    不能传指针， 可以传一个const引用（右值不能直接传引用）

    但这个std::initial_list<int> 最好不要用作函数类型，因为返回值是这个类型，但是这个类型会被实例化后销毁（这个类型实际上是两个指针），所以返回值是未定义的

  - 使用可变长度模板参数（不限制传入参数类型是否相同）

  - 用省略号表示形式参数 （C中常用）printf

- 函数可以定义缺省实参  **void** fun7( **int** x = 0)

  - 可以不用传实参，直接使用缺省值进行计算

  - 如果某个函数的参数具有缺省实参，则这个形参的右边都应具有缺省实参（避免歧义）

  - 在一个翻译单元中，每个形参的缺省实参只能定义一次

    翻译单元：一个cpp文件中，函数的声明和定义中不能多次定义缺省实参，一样的结果也不行

    在声明的时候可能会出现不是每个形参右边都有缺省值的情况，但一定保证在上一次声明的时候已经有缺省值的声明（出现这种情况的原因，是某一个缺省值可以在头文件中进行定义，头文件等于直接将头文件中的代码复制粘贴，这样即进行了分级指定：最不重要的参数放在函数的最后，可以放在头文件中）

    也就是说，另一个cpp文件中，可以对同一个函数中的形参赋予不同的缺省值，因为编译期二者无关。

  - 缺省实参为对象时，实参的缺省值会随对象值的变化而变化（不建议）

    int x = 3; void fun(int y = x){cout y}           / /fun(x) ,x改变后cout的结果会变（不要重新int x）

  - main函数的两个版本（无形参版本，有两个形参版本）

    int main() {}

    int main(int argc, char* argv[]) {} argc代表里面有几个参数，argv是带有名称的字符串数组，第一个指针指向可执行程序（的名称）（argv[0]）

    （使用命令行给main传递参数）

## 函数体

- 函数体形成了一个域：其中包含自动对象（内部的声明对象和局部静态对象）内部对象在栈中的结构见上文（帧被弹出，自动对象自动销毁，栈中的执行效率更高，因为对象位置接近）

  局部静态对象：static int x = 1; //x的生存周期从调用函数开始，到整个程序结束为止一直存在，但仅仅在函数内部可见（并不会因为函数的重新调用而被刷新，局部静态对象只会被初始化一次）

- 函数体执行的返回：

  - 隐式返回 void型函数

  - 显式返回关键字 return

    return；语句（可以用作void函数中，可以提前跳出函数）

    return 表达式；返回一个具体的对象，与函数类型相比配（或者可以转化成与函数类型相匹配的类型）

    return 初始化列表（如std:: vector<int>型，可以return一个{1，2，3，4，5}）

  - 小心返回自动对象的指针（之前提到的initializer_list）和引用 （ int& fun(), 指向一个被销毁的对象（内部函数中 返回值的指向的对象 会在函数执行结束后被销毁），如果使用static int便可以避免这个问题）

  - 返回值优化（RVO） C++17开始对返回临时对象的强制优化

## 函数返回类型

- 返回类型在声明的时候就已经确定了，返回类型决定了函数计算的类型，可以为void

- 返回类型的几种书写方式

  - 经典方法：位于函数体的初始位置  int fun()

  - C++11引入：位于函数头的后部  auto fun()  ->void（泛型编程，定义类的成员函数）

  - C++14引入：返回类型的自动推导（auto fun   ( ) ）[使用retrun语句推导]：return类型必须一致    使用decltype(auto) fun()  不会产生类型自动退化

    -  使用 constexpr if 构造"具有不同返回类型"的函数,会在编译期进行求值，一定会返回其中一个值，所以不存在冲突

      ```c++
      constexpr bool value = false;
      auto fun()
      {
          if constexpr (value){
              return 1;
          }
          else {
              return 0.1;
          }
      }
      ```

```C++
struct Str{
    int x;
    int y;
};
Str fun(){
    return Str{};
}
int main() {
    auto [res1, res2] = fun(); //res1 -x, res2 -y 也可以用res，然后res.x,res.y
    auto& [res1, res2] = fun(); //程序会出错，因为fun返回的是一个右值不能引用（而且这个右值也被销毁了），解决方法是把Str fun（） 变成 Str& fun（），且内部生成一个static Str x，并 return x；
    
}
```

上述为返回类型的结构化绑定（C++17）

[ [nodiscard] ] 属性（C++17）

```c++
int fun(int a, int b){
    return a+b;
}
int main() {
    fun(2,3) //完全没有必要，加完了之后没有传给任何一个对象
}

[[nodiscard]] int fun(int a, int b){
    return a+b;
} //此时再次调用的时候会报错，提醒没有使用返回值；
```

## 函数重载

- 不能基于不同的返回类型进行重载；（声明不能有歧义，两个函数要完全区分开（函数名一致的情况下））

- 编译器如何选择适合的版本？cppcon calling functions a tutorial

  - 名称查找：限定查找（有：：域限定符）与非限定查找

    - 非限定查找会根据域逐级查找（从内向外，先本身名字空间或本身域，再到全局域，同域内也有先后顺序的问题）

      **名称**隐藏效应（一定是查找名称）

    - 查找*通常*只会在已声明的函数中

    - 实参依赖查找：如果函数定义的实参str是在一个名字空间中，那么全局域的函数也会在这个名字空间查找；（这个实参类型不能在全局域中出现，即自定义类型）

  - 重载解析：名称查找基础之上的行为（重载决议）

    - 过滤不能被调用的版本：参数个数不对，形参类型不匹配，无法转换或不满足限制条件

    - 在剩余版本中查找与调用表达式最匹配的版本，匹配级别越低越好

      - 级别一：完美匹配或平凡转换（比如加一个const）//否则可能会看成重定义函数
      - 级别二：promotion或promotion加平凡转换（int——double）
      - 级别三：标准转换或+平凡转换
      - 级别四：自定义转换
      - 级别五：形参为省略号的版本
      - 函数有多个形参时。所选函数的所有形参匹配级别都要优于其他函数，如果有歧义会报warning

      

## 函数的其他内容

- 递归函数：函数中调用自身（类似于循环）

  二分查找：有序数组

- 内联函数：解决性能问题，函数过于简单，维护栈帧意义不大

  inline void  fun() {}  会**在编译的时候**直接把函数复制到main中对应位置，没有额外栈帧（但也会保证形成独立域）；inline是对编译器的一个建议，如果很复杂还是会形成一个栈帧（过于长或者是一个无法展开的递归函数），如果函数只有声明，定义在另一个cpp文件，那么就会出现链接错误，因为编译有声明可以正确，但是链接期找不到函数具体定义

  *翻译单元级别的一次定义函数* 可以在不同的cpp中分别定义，但内容应该是完全一致

- constexpr函数，可以在编译期确定（函数不止可以在运行期被调用，编译期也可以被调用），函数体内的语句必须在编译器可以确定；

  C++开启，C++14丰富

- consteval函数 C++20开始 函数只能在编译期被调用，不能在运行期被调用（引入更多限制进行优化）

- 函数指针（*选学）

  - 函数类型与函数指针类型：类型 int(int) --返回值类型（形参类型）

    using F = int(int)

    F fun;  //等于 int fun(int a)；只是函数的声明

    F* fun //fun是一个函数指针类型的变量

    F* fun_ = &fun; //指向fun函数的指针fun_(需要满足函数类型)

    好处  可以构建高阶函数，在另一个函数中引用另一个函数时，这个函数也是可变的；

    函数的退化也是一个函数指针类型，所以传函数作为形参的时候穿函数本身名称和指针是一个效果，但是不能定义函数的返回类型是一个函数，只能是一个函数指针（但是看起来还可以是函数名称，因为会退化）

    auto x = fun；// x也是一个函数指针，但是没法重载，因为会生成不同的函数指针类型

  - 小心：most vexing parse，可以看作函数声明，或者变量声明，具有歧义性

    TimeKeeper time_keeper( Timer() );  //timer是一个缺省初始化的对象



