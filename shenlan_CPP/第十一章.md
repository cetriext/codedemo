# 第十一章 类与面向对象编程

## 结构体与对象聚合

- 结构体：对基本数据结构进行扩展，将多个对象放置在一起视为一个整体

  结构体需要加分号，可可以赋予结构别名 typedef () +别名；

  仅有声明的结构体是不完全类型 （struct Str;）无法定义Str，但可以使用Str* （Str* x是合法的）

  结构体（以及类）的一处定义原则：翻译单元级别（不同的cpp文件可以重复定义）

- 数据成员（数据域）的声明与初始化（结构体中间定义的变量）
  - （C++ 11）结构体的定义包含的数据成员是声明（不是定义，或可理解为隐式定义）数据成员可以使用decltype声明其类型（decltype（3） x）不能用auto
  - 可以加入const 引用等限定
  - （C++11起）类内成员初始化，定义的同时就初始化
  - 聚合初始化：结构体中未赋值的数据成员会默认缺省值 Str m_str{3} ({3,4}) 20起引入一个指定初始化（给出名字，x  =，， y = ，，，（类似python））
  - 定义结构体使用const（main中），里面的对象不能改变，那可以在这个对象前加一个mutable（结构体中）const和mutable的位置不能改
- 静态数据成员--多个对象之间共享的数据成员
  - Str x1; Str x2两个对象，对x1中数据的修改不会改变x2中的数据
  - 声明静态数据成员（结构体中）static int x ；并在结构体外 int Str::x（代表x的所在域）;
  - 定义方式的演化：
    - C++98: 类内声明，类外初始化，结构体声明可以在头文件，但是要在具体的cpp文件中再定义（int Str::x）（所有cpp定义一次就可，否则会在链接时出错，如果要求这个数值在编译期确定（比如数组大小），那需要在定义的时候 const static int xx = 100）
    - C++17:内联静态成员初始化 inline const static int x = 100；或inline static int x = 100（甚至可以修改）
  - 可以使用auto推导静态数类型inline static auto x = 100（只支持**静态数据成员**）
- 静态数据成员的访问：
  - 使用. ->
  - ::操作符
- 在类的内部声明相同类型的数据成员 在Str内嵌套Str 要用static Str x；（但此时只是声明，没有定义，定义，在另一个cpp或结构体外 Str Str::x;  不能使用inline类型在结构体外定义。但是可以在结构体外 inline Str Str::x;定义可以避免在头文件中，多次引入造成重复定义）